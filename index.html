<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mental Math Weakness Trainer</title>
  <style>
    :root {
      --bg-1: #f4f7ff;
      --bg-2: #dff1ff;
      --panel: #ffffff;
      --text: #172554;
      --muted: #456;
      --accent: #0f766e;
      --accent-2: #0891b2;
      --ok: #15803d;
      --bad: #b91c1c;
      --line: #d9e2ef;
      --shadow: 0 14px 35px rgba(23, 37, 84, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 0% 0%, #ffffff 0%, var(--bg-1) 35%, var(--bg-2) 100%);
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .app {
      width: min(920px, 100%);
      background: #ffffff;
      border: 1px solid #e5edfa;
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .hero {
      padding: 28px 24px 18px;
      background: linear-gradient(125deg, #ecfeff 0%, #eff6ff 55%, #ffffff 100%);
      border-bottom: 1px solid #e3eef9;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.5rem, 4vw, 2.1rem);
      letter-spacing: 0.02em;
    }

    .subtitle {
      margin: 8px 0 0;
      color: #375;
      max-width: 68ch;
      line-height: 1.45;
    }

    .view-tabs {
      margin-top: 14px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab {
      border: 1px solid #bcd0eb;
      background: #f4f8ff;
      color: #204;
      border-radius: 999px;
      padding: 7px 14px;
      font-weight: 700;
      cursor: pointer;
    }

    .tab.active {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      border-color: transparent;
    }

    .section {
      padding: 22px 24px;
    }

    .controls {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: end;
    }

    .field {
      display: grid;
      gap: 6px;
      min-width: 160px;
      flex: 1;
    }

    label {
      font-weight: 600;
      color: #245;
      font-size: 0.95rem;
    }

    select,
    input,
    button {
      font: inherit;
    }

    select,
    input[type="text"] {
      border: 1px solid #c7d5ea;
      border-radius: 10px;
      padding: 11px 12px;
      width: 100%;
      background: #fff;
      color: var(--text);
    }

    .button {
      border: none;
      border-radius: 12px;
      padding: 11px 18px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.2s ease;
      min-height: 44px;
    }

    .button:hover {
      filter: brightness(1.05);
    }

    .button:active {
      transform: translateY(1px);
    }

    .button.secondary {
      background: linear-gradient(135deg, #334155, #475569);
    }

    .button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .game {
      border-top: 1px solid var(--line);
      border-bottom: 1px solid var(--line);
      background: #fbfdff;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
    }

    .metrics {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      background: #ecf4ff;
      border: 1px solid #d5e6ff;
      border-radius: 999px;
      padding: 7px 12px;
      font-weight: 700;
      color: #123;
    }

    .mode {
      color: #144;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .hint {
      margin: 10px 0 0;
      color: #365;
      font-size: 0.93rem;
      line-height: 1.4;
    }

    .problem {
      font-size: clamp(2rem, 6vw, 3.1rem);
      font-weight: 800;
      letter-spacing: 0.03em;
      margin: 10px 0 16px;
    }

    form {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    #answer {
      width: 160px;
      text-align: center;
      font-size: 1.15rem;
      font-weight: 700;
    }

    .feedback {
      min-height: 1.3em;
      margin-top: 10px;
      font-weight: 600;
    }

    .feedback.ok {
      color: var(--ok);
    }

    .feedback.bad {
      color: var(--bad);
    }

    .results {
      background: #fff;
    }

    .stats-page {
      background: #fff;
      border-top: 1px solid var(--line);
    }

    #statsPage {
      display: none;
    }

    .app.stats-mode .practice-only {
      display: none !important;
    }

    .app.stats-mode #statsPage {
      display: block !important;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 14px;
      margin: 12px 0 16px;
    }

    .stats-panel {
      border: 1px solid #dce8f7;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 14px;
    }

    .stats-panel h3 {
      margin: 0;
      padding: 11px 12px;
      border-bottom: 1px solid #e4ecf8;
      background: #f7fbff;
      font-size: 1rem;
      color: #163;
    }

    .muted {
      color: #4a6280;
    }

    .tier-badge {
      display: inline-block;
      min-width: 34px;
      text-align: center;
      font-weight: 800;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.78rem;
      border: 1px solid transparent;
    }

    .tier-s {
      color: #0b5;
      background: #e8fff2;
      border-color: #b8f2d5;
    }

    .tier-a {
      color: #0f766e;
      background: #e7fcfb;
      border-color: #b9ece8;
    }

    .tier-b {
      color: #0369a1;
      background: #eaf5ff;
      border-color: #c7e4ff;
    }

    .tier-c {
      color: #a16207;
      background: #fff8e8;
      border-color: #f8e2b8;
    }

    .tier-d {
      color: #b45309;
      background: #fff3e6;
      border-color: #ffd5ad;
    }

    .tier-f {
      color: #b91c1c;
      background: #ffecec;
      border-color: #ffc5c5;
    }

    .chart-panel {
      margin-bottom: 14px;
      border: 1px solid #dce8f7;
      border-radius: 12px;
      overflow: hidden;
    }

    .chart-panel h3 {
      margin: 0;
      padding: 11px 12px;
      border-bottom: 1px solid #e4ecf8;
      background: #f7fbff;
      font-size: 1rem;
      color: #163;
    }

    .chart-body {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .chart-row {
      display: grid;
      grid-template-columns: 96px 1fr auto auto;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
    }

    .chart-label {
      font-weight: 700;
      color: #214;
    }

    .chart-track {
      height: 10px;
      border-radius: 999px;
      background: #eaf1fb;
      overflow: hidden;
      border: 1px solid #d5e2f3;
    }

    .chart-fill {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #f59e0b, #ef4444);
    }

    .chart-value {
      min-width: 58px;
      text-align: right;
      color: #234;
      font-weight: 700;
    }

    .heatmap-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(104px, 1fr));
      gap: 8px;
    }

    .heat-cell {
      border-radius: 10px;
      border: 1px solid #d4e0f0;
      padding: 8px;
      display: grid;
      gap: 4px;
      color: #102a43;
      background: #f9fcff;
    }

    .heat-cell .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 700;
    }

    .heat-cell .sub {
      font-size: 0.8rem;
      color: #375;
    }

    .tier-stack {
      border: 1px solid #d5e2f3;
      border-radius: 999px;
      overflow: hidden;
      height: 16px;
      display: flex;
      background: #eaf1fb;
    }

    .tier-segment {
      height: 100%;
      min-width: 2px;
    }

    .tier-legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 0.82rem;
      color: #27496b;
    }

    .summary {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }

    .card {
      border: 1px solid #dce8f7;
      background: #f8fbff;
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 650;
    }

    .weakness {
      margin: 12px 0 16px;
      padding: 11px 13px;
      border-radius: 10px;
      background: #ecfeff;
      border: 1px solid #c4f2f6;
      color: #0f4c5d;
      font-weight: 600;
      line-height: 1.4;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
    }

    th,
    td {
      padding: 8px 10px;
      border-bottom: 1px solid #ecf0f7;
      text-align: left;
    }

    th {
      color: #27496b;
      font-size: 0.87rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    tr.top {
      background: #fffce8;
    }

    .bar-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .bar {
      height: 8px;
      min-width: 12px;
      border-radius: 6px;
      background: linear-gradient(90deg, #f59e0b, #ef4444);
    }

    .hidden {
      display: none;
    }

    @media (max-width: 640px) {
      .section,
      .hero {
        padding: 18px;
      }

      #answer {
        width: 130px;
      }

      .problem {
        font-size: clamp(1.7rem, 10vw, 2.5rem);
      }

      table {
        font-size: 0.88rem;
      }
    }
  </style>
</head>
<body>
  <main id="appRoot" class="app">
    <header class="hero">
      <h1>Mental Math Weakness Trainer</h1>
      <p class="subtitle">Adaptive arithmetic rounds inspired by Zetamac. Run a mixed diagnostic first, then use an automatically curated booster designed to improve your speed for 2-12 x 2-100 multiplication.</p>
      <div class="view-tabs" role="tablist" aria-label="View">
        <button id="practiceTabBtn" class="tab active" type="button">Practice</button>
        <button id="statsTabBtn" class="tab" type="button">Stats Page</button>
      </div>
    </header>

    <section class="section practice-only">
      <div class="controls">
        <div class="field">
          <label for="questionSet">Question Type</label>
          <select id="questionSet">
            <option value="diagnostic-mixed" selected>Diagnostic Mixed (+, -, x, /)</option>
            <option value="curated-zetamac">Curated Zetamac Booster (adaptive)</option>
            <option value="times-normal">Times Tables (normal)</option>
            <option value="times-wide">Times Tables (2-12 x 2-100)</option>
            <option value="addition">Addition</option>
            <option value="subtraction">Subtraction</option>
            <option value="division">Division</option>
            <option value="mixed">Mixed (+, -, x, /)</option>
          </select>
        </div>
        <div class="field">
          <label for="duration">Round Length</label>
          <select id="duration">
            <option value="60">60 seconds</option>
            <option value="120" selected>120 seconds</option>
            <option value="180">180 seconds</option>
          </select>
        </div>
        <div class="field">
          <label for="maxTable">Largest Times Table</label>
          <select id="maxTable">
            <option value="10">Up to 10</option>
            <option value="12" selected>Up to 12</option>
            <option value="15">Up to 15</option>
            <option value="20">Up to 20</option>
          </select>
        </div>
        <button id="startBtn" class="button">Start Round</button>
      </div>
      <p id="setHint" class="hint">Run the mixed diagnostic first. Then use Curated Zetamac Booster to train your weakest tables for 2-12 x 2-100.</p>
    </section>

    <section id="game" class="section game hidden practice-only">
      <div class="hud">
        <div class="metrics">
          <div id="timer" class="pill">120.0s</div>
          <div id="score" class="pill">Score: 0</div>
          <div id="accuracy" class="pill">Accuracy: 0%</div>
        </div>
        <div id="mode" class="mode">Waiting to start</div>
      </div>

      <div id="problem" class="problem">8 x 7 = ?</div>

      <form id="answerForm" autocomplete="off">
        <input id="answer" type="text" inputmode="numeric" aria-label="Answer" placeholder="Answer" />
        <button class="button" type="submit">Submit</button>
      </form>

      <div id="feedback" class="feedback" aria-live="polite"></div>
    </section>

    <section id="results" class="section results hidden practice-only">
      <h2>Round Results</h2>
      <div id="summary" class="summary"></div>
      <div id="weakness" class="weakness"></div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:14px;">
        <button id="practiceWeakestBtn" class="button secondary hidden">Practice Weakest Area</button>
        <button id="newBalancedBtn" class="button">Start Round With Current Settings</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>Area</th>
            <th>Attempts</th>
            <th>Total Time</th>
            <th>Avg / Prompt</th>
            <th>Accuracy</th>
          </tr>
        </thead>
        <tbody id="tableStatsBody"></tbody>
      </table>
    </section>

    <section id="statsPage" class="section stats-page">
      <h2>Lifetime Stats</h2>
      <p class="muted">Cumulative performance across all rounds on this browser.</p>
      <div id="statsOverview" class="stats-grid"></div>
      <div class="chart-panel">
        <h3>Visual Analytics</h3>
        <div class="chart-body">
          <div class="muted">Operation speed (slower bars indicate weaker areas)</div>
          <div id="operationSpeedChart"></div>
          <div class="muted">Multiplication table heatmap</div>
          <div id="tableHeatmap" class="heatmap-grid"></div>
          <div class="muted">Speed tier distribution</div>
          <div id="tierDistributionBar" class="tier-stack"></div>
          <div id="tierLegend" class="tier-legend"></div>
        </div>
      </div>
      <div class="stats-panel">
        <h3>By Operation</h3>
        <table>
          <thead>
            <tr>
              <th>Operation</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="operationStatsBody"></tbody>
        </table>
      </div>
      <div class="stats-panel">
        <h3>Multiplication Tables</h3>
        <table>
          <thead>
            <tr>
              <th>Table</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="multiplicationStatsBody"></tbody>
        </table>
      </div>
      <div class="stats-panel">
        <h3>Division Tables (by divisor)</h3>
        <table>
          <thead>
            <tr>
              <th>Divisor</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="divisionStatsBody"></tbody>
        </table>
      </div>
      <div class="stats-panel">
        <h3>Multiplication Single-Fact Patterns</h3>
        <table>
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="multiplicationSingleStatsBody"></tbody>
        </table>
      </div>
      <div class="stats-panel">
        <h3>Addition Ones-Digit Pairs</h3>
        <table>
          <thead>
            <tr>
              <th>Pair</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="additionPairStatsBody"></tbody>
        </table>
      </div>
      <div class="stats-panel">
        <h3>Subtraction Ones-Digit Pairs</h3>
        <table>
          <thead>
            <tr>
              <th>Pair</th>
              <th>Attempts</th>
              <th>Accuracy</th>
              <th>Avg / Prompt</th>
              <th>Tier</th>
            </tr>
          </thead>
          <tbody id="subtractionPairStatsBody"></tbody>
        </table>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="resetStatsBtn" class="button secondary" type="button">Reset Lifetime Stats</button>
      </div>
    </section>
  </main>

  <script>
    const OPERATION_LABELS = {
      add: "Addition",
      sub: "Subtraction",
      mul: "Multiplication",
      div: "Division"
    };
    const OPERATION_ORDER = ["add", "sub", "mul", "div"];
    const DIAGNOSTIC_OP_CYCLE = ["mul", "add", "mul", "sub", "mul", "div"];
    const CURATED_BASE_OPERATION_WEIGHTS = {
      mul: 0.62,
      add: 0.14,
      sub: 0.14,
      div: 0.10
    };
    const SPEED_TIERS = [
      { id: "S", label: "Elite", maxSeconds: 1.6, color: "#22c55e" },
      { id: "A", label: "Fast", maxSeconds: 2.2, color: "#10b981" },
      { id: "B", label: "Solid", maxSeconds: 2.9, color: "#0ea5e9" },
      { id: "C", label: "Building", maxSeconds: 3.8, color: "#f59e0b" },
      { id: "D", label: "Developing", maxSeconds: 5.0, color: "#f97316" },
      { id: "F", label: "Needs work", maxSeconds: Number.POSITIVE_INFINITY, color: "#ef4444" }
    ];
    const CURATED_BALANCE_RATIO_TARGET = 1.22;
    const CURATED_SPEED_IMPROVEMENT_TARGET = 0.93;
    const CURATED_MIN_TABLE_ATTEMPTS = 3;
    const LIFETIME_STORAGE_KEY = "mental_math_lifetime_stats_v1";

    const state = {
      active: false,
      timerId: null,
      endAt: 0,
      durationSec: 120,
      maxTable: 12,
      questionSet: "diagnostic-mixed",
      focusKey: null,
      attempted: 0,
      correct: 0,
      score: 0,
      questionStartedAt: 0,
      currentQuestion: null,
      areaStats: {},
      curatedPlan: null,
      diagnosticOpBag: [],
      diagnosticMulTableBag: [],
      lifetimeStats: null,
      currentView: "practice",
      feedbackTimeoutId: null,
      coachCycle: 0
    };

    const startBtn = document.getElementById("startBtn");
    const practiceTabBtn = document.getElementById("practiceTabBtn");
    const statsTabBtn = document.getElementById("statsTabBtn");
    const questionSetSelect = document.getElementById("questionSet");
    const durationSelect = document.getElementById("duration");
    const maxTableSelect = document.getElementById("maxTable");
    const setHintEl = document.getElementById("setHint");
    const appRoot = document.getElementById("appRoot");

    const gameSection = document.getElementById("game");
    const timerEl = document.getElementById("timer");
    const scoreEl = document.getElementById("score");
    const accuracyEl = document.getElementById("accuracy");
    const modeEl = document.getElementById("mode");
    const problemEl = document.getElementById("problem");
    const feedbackEl = document.getElementById("feedback");
    const answerForm = document.getElementById("answerForm");
    const answerInput = document.getElementById("answer");

    const resultsSection = document.getElementById("results");
    const summaryEl = document.getElementById("summary");
    const weaknessEl = document.getElementById("weakness");
    const tableStatsBody = document.getElementById("tableStatsBody");
    const practiceWeakestBtn = document.getElementById("practiceWeakestBtn");
    const newBalancedBtn = document.getElementById("newBalancedBtn");
    const statsOverviewEl = document.getElementById("statsOverview");
    const operationSpeedChartEl = document.getElementById("operationSpeedChart");
    const tableHeatmapEl = document.getElementById("tableHeatmap");
    const tierDistributionBarEl = document.getElementById("tierDistributionBar");
    const tierLegendEl = document.getElementById("tierLegend");
    const operationStatsBody = document.getElementById("operationStatsBody");
    const multiplicationStatsBody = document.getElementById("multiplicationStatsBody");
    const divisionStatsBody = document.getElementById("divisionStatsBody");
    const multiplicationSingleStatsBody = document.getElementById("multiplicationSingleStatsBody");
    const additionPairStatsBody = document.getElementById("additionPairStatsBody");
    const subtractionPairStatsBody = document.getElementById("subtractionPairStatsBody");
    const resetStatsBtn = document.getElementById("resetStatsBtn");

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function pickRandom(list) {
      return list[randInt(0, list.length - 1)];
    }

    function shuffleCopy(list) {
      const copy = list.slice();
      for (let index = copy.length - 1; index > 0; index -= 1) {
        const swapIndex = randInt(0, index);
        [copy[index], copy[swapIndex]] = [copy[swapIndex], copy[index]];
      }
      return copy;
    }

    function drawFromBag(stateKey, sourceValues, shouldShuffle = true) {
      if (!state[stateKey] || !state[stateKey].length) {
        state[stateKey] = shouldShuffle ? shuffleCopy(sourceValues) : sourceValues.slice();
      }
      return state[stateKey].pop();
    }

    function clearPendingFeedbackTimeout() {
      if (state.feedbackTimeoutId) {
        clearTimeout(state.feedbackTimeoutId);
        state.feedbackTimeoutId = null;
      }
    }

    function createStatBucket() {
      return {
        attempts: 0,
        correct: 0,
        totalTimeMs: 0
      };
    }

    function createLifetimeStats() {
      return {
        totals: createStatBucket(),
        operations: {
          add: createStatBucket(),
          sub: createStatBucket(),
          mul: createStatBucket(),
          div: createStatBucket()
        },
        multiplicationTables: {},
        divisionTables: {},
        multiplicationSingles: {},
        additionPairs: {},
        subtractionPairs: {}
      };
    }

    function ensureLifetimeBucket(map, key) {
      if (!map[key]) {
        map[key] = createStatBucket();
      }
      return map[key];
    }

    function safeNumber(value) {
      return Number.isFinite(value) ? value : 0;
    }

    function normalizeBucket(raw) {
      return {
        attempts: Math.max(0, Math.floor(safeNumber(raw && raw.attempts))),
        correct: Math.max(0, Math.floor(safeNumber(raw && raw.correct))),
        totalTimeMs: Math.max(0, safeNumber(raw && raw.totalTimeMs))
      };
    }

    function normalizeBucketMap(rawMap) {
      const result = {};
      if (!rawMap || typeof rawMap !== "object") {
        return result;
      }
      Object.keys(rawMap).forEach((key) => {
        result[key] = normalizeBucket(rawMap[key]);
      });
      return result;
    }

    function normalizeLifetimeStats(raw) {
      const fallback = createLifetimeStats();
      if (!raw || typeof raw !== "object") {
        return fallback;
      }
      const normalized = {
        totals: normalizeBucket(raw.totals),
        operations: {
          add: normalizeBucket(raw.operations && raw.operations.add),
          sub: normalizeBucket(raw.operations && raw.operations.sub),
          mul: normalizeBucket(raw.operations && raw.operations.mul),
          div: normalizeBucket(raw.operations && raw.operations.div)
        },
        multiplicationTables: normalizeBucketMap(raw.multiplicationTables),
        divisionTables: normalizeBucketMap(raw.divisionTables),
        multiplicationSingles: normalizeBucketMap(raw.multiplicationSingles),
        additionPairs: normalizeBucketMap(raw.additionPairs),
        subtractionPairs: normalizeBucketMap(raw.subtractionPairs)
      };
      return normalized;
    }

    function saveLifetimeStats() {
      try {
        localStorage.setItem(LIFETIME_STORAGE_KEY, JSON.stringify(state.lifetimeStats));
      } catch (error) {
        // Ignore storage failures to keep gameplay uninterrupted.
      }
    }

    function loadLifetimeStats() {
      const fallback = createLifetimeStats();
      try {
        const raw = localStorage.getItem(LIFETIME_STORAGE_KEY);
        if (!raw) {
          state.lifetimeStats = fallback;
          return;
        }
        state.lifetimeStats = normalizeLifetimeStats(JSON.parse(raw));
      } catch (error) {
        state.lifetimeStats = fallback;
      }
    }

    function clearElementChildren(element) {
      element.innerHTML = "";
    }

    function bucketToMetrics(bucket) {
      const attempts = bucket.attempts || 0;
      const accuracyPct = attempts ? Math.round((bucket.correct / attempts) * 100) : 0;
      const avgSeconds = attempts ? bucket.totalTimeMs / attempts / 1000 : 0;
      return {
        attempts,
        accuracyPct,
        avgSeconds,
        hasData: attempts > 0
      };
    }

    function getSpeedTier(avgSeconds) {
      for (const tier of SPEED_TIERS) {
        if (avgSeconds <= tier.maxSeconds) {
          return tier;
        }
      }
      return SPEED_TIERS[SPEED_TIERS.length - 1];
    }

    function tierClassForId(tierId) {
      return `tier-${String(tierId || "f").toLowerCase()}`;
    }

    function bucketWeaknessScore(bucket, baselineMs = 2400) {
      const attempts = bucket.attempts || 0;
      if (!attempts) {
        return null;
      }
      const avgMs = bucket.totalTimeMs / attempts;
      const errorRate = 1 - bucket.correct / attempts;
      const smoothedAvg = (avgMs * attempts + baselineMs * 3) / (attempts + 3);
      return smoothedAvg * (1 + errorRate * 2);
    }

    function topWeakRowsFromMap(map, labelBuilder, options = {}) {
      const minAttempts = options.minAttempts || 2;
      const limit = options.limit || 6;
      const rows = Object.keys(map || {})
        .map((key) => {
          const bucket = map[key];
          const score = bucketWeaknessScore(bucket);
          if (score === null || bucket.attempts < minAttempts) {
            return null;
          }
          return {
            key,
            label: labelBuilder(key),
            attempts: bucket.attempts,
            score,
            bucket
          };
        })
        .filter(Boolean)
        .sort((a, b) => b.score - a.score);
      return rows.slice(0, limit);
    }

    function digitsFromNumber(value) {
      return String(Math.abs(value))
        .split("")
        .map((char) => Number(char))
        .filter((digit) => Number.isInteger(digit));
    }

    function average(values, fallback = 0) {
      if (!values.length) {
        return fallback;
      }
      return values.reduce((sum, value) => sum + value, 0) / values.length;
    }

    function applyRankWeights(rows, spread = 3, minWeight = 1) {
      if (!rows.length) {
        return rows;
      }
      const maxScore = rows[0].score || 1;
      rows.forEach((row, index) => {
        const normalized = row.score / maxScore;
        const rankBoost = (rows.length - index) / rows.length;
        row.weight = minWeight + normalized * spread + rankBoost;
      });
      return rows;
    }

    function parseMulSingleKey(key) {
      const match = /^(\d+)x(\d+)$/.exec(key);
      if (!match) {
        return null;
      }
      return {
        table: Number(match[1]),
        digit: Number(match[2])
      };
    }

    function parseAddPairKey(key) {
      const match = /^(\d+)\+(\d+)$/.exec(key);
      if (!match) {
        return null;
      }
      return {
        a: Number(match[1]),
        b: Number(match[2])
      };
    }

    function parseSubPairKey(key) {
      const match = /^(\d+)-(\d+)$/.exec(key);
      if (!match) {
        return null;
      }
      return {
        a: Number(match[1]),
        b: Number(match[2])
      };
    }

    function renderStatsTableRows(bodyEl, rows, emptyLabel) {
      clearElementChildren(bodyEl);
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="5" class="muted">${emptyLabel}</td>`;
        bodyEl.appendChild(tr);
        return;
      }
      rows.forEach((row) => {
        const tier = row.hasData ? getSpeedTier(row.avgSeconds) : null;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.label}</td>
          <td>${row.attempts}</td>
          <td>${row.hasData ? `${row.accuracyPct}%` : "--"}</td>
          <td>${row.hasData ? `${row.avgSeconds.toFixed(2)}s` : "--"}</td>
          <td>${row.hasData ? `<span class="tier-badge ${tierClassForId(tier.id)}">${tier.id}</span>` : "--"}</td>
        `;
        bodyEl.appendChild(tr);
      });
    }

    function renderOperationSpeedChart(rows) {
      clearElementChildren(operationSpeedChartEl);
      const dataRows = rows.filter((row) => row.hasData);
      if (!dataRows.length) {
        operationSpeedChartEl.innerHTML = `<div class="muted">No operation data yet.</div>`;
        return;
      }
      const maxAvg = Math.max(...dataRows.map((row) => row.avgSeconds), 0.1);
      dataRows.forEach((row) => {
        const tier = getSpeedTier(row.avgSeconds);
        const widthPct = Math.max(6, Math.round((row.avgSeconds / maxAvg) * 100));
        const wrapper = document.createElement("div");
        wrapper.className = "chart-row";
        wrapper.innerHTML = `
          <div class="chart-label">${row.label}</div>
          <div class="chart-track">
            <div class="chart-fill" style="width:${widthPct}%"></div>
          </div>
          <div class="chart-value">${row.avgSeconds.toFixed(2)}s</div>
          <div><span class="tier-badge ${tierClassForId(tier.id)}">${tier.id}</span></div>
        `;
        operationSpeedChartEl.appendChild(wrapper);
      });
    }

    function renderTableHeatmap(rows) {
      clearElementChildren(tableHeatmapEl);
      const dataRows = rows.filter((row) => row.hasData);
      if (!dataRows.length) {
        tableHeatmapEl.innerHTML = `<div class="muted">No multiplication table data yet.</div>`;
        return;
      }
      const maxAvg = Math.max(...dataRows.map((row) => row.avgSeconds), 0.1);
      const minAvg = Math.min(...dataRows.map((row) => row.avgSeconds));
      const spread = Math.max(0.01, maxAvg - minAvg);
      dataRows.forEach((row) => {
        const tier = getSpeedTier(row.avgSeconds);
        const normalized = (row.avgSeconds - minAvg) / spread;
        const hue = 120 - normalized * 120;
        const cell = document.createElement("div");
        cell.className = "heat-cell";
        cell.style.background = `hsl(${hue} 92% 95%)`;
        cell.style.borderColor = `hsl(${hue} 60% 78%)`;
        cell.innerHTML = `
          <div class="head">
            <span>${row.label}</span>
            <span class="tier-badge ${tierClassForId(tier.id)}">${tier.id}</span>
          </div>
          <div class="sub">${row.avgSeconds.toFixed(2)}s avg</div>
          <div class="sub">${row.attempts} attempts</div>
        `;
        tableHeatmapEl.appendChild(cell);
      });
    }

    function renderTierDistribution(rows) {
      clearElementChildren(tierDistributionBarEl);
      clearElementChildren(tierLegendEl);
      const dataRows = rows.filter((row) => row.hasData);
      if (!dataRows.length) {
        tierLegendEl.innerHTML = `<span class="muted">No tier distribution yet.</span>`;
        return;
      }
      const counts = {};
      SPEED_TIERS.forEach((tier) => {
        counts[tier.id] = 0;
      });
      dataRows.forEach((row) => {
        const tier = getSpeedTier(row.avgSeconds);
        counts[tier.id] += 1;
      });
      const total = dataRows.length;
      SPEED_TIERS.forEach((tier) => {
        const count = counts[tier.id];
        if (!count) {
          return;
        }
        const segment = document.createElement("div");
        segment.className = "tier-segment";
        segment.style.width = `${(count / total) * 100}%`;
        segment.style.background = tier.color;
        segment.title = `${tier.id} (${tier.label}): ${count}`;
        tierDistributionBarEl.appendChild(segment);

        const legend = document.createElement("span");
        legend.innerHTML = `<span class="tier-badge ${tierClassForId(tier.id)}">${tier.id}</span> ${tier.label} (${count})`;
        tierLegendEl.appendChild(legend);
      });
    }

    function renderStatsPage() {
      if (!state.lifetimeStats) {
        return;
      }

      const totals = bucketToMetrics(state.lifetimeStats.totals);
      const overallTier = totals.hasData ? getSpeedTier(totals.avgSeconds) : null;
      const cycleLabel = state.coachCycle ? String(state.coachCycle) : "Not started";
      clearElementChildren(statsOverviewEl);
      const cards = [
        `Total prompts: ${totals.attempts}`,
        `Total correct: ${state.lifetimeStats.totals.correct}`,
        `Lifetime accuracy: ${totals.accuracyPct}%`,
        `Average time: ${totals.hasData ? `${totals.avgSeconds.toFixed(2)}s` : "--"}`,
        `Speed tier: ${overallTier ? `${overallTier.id} (${overallTier.label})` : "--"}`,
        `Coaching cycle: ${cycleLabel}`
      ];
      cards.forEach((text) => {
        const card = document.createElement("div");
        card.className = "card";
        card.textContent = text;
        statsOverviewEl.appendChild(card);
      });

      const operationRows = OPERATION_ORDER.map((operation) => {
        const metrics = bucketToMetrics(state.lifetimeStats.operations[operation]);
        return {
          label: OPERATION_LABELS[operation],
          ...metrics
        };
      });
      renderStatsTableRows(operationStatsBody, operationRows, "No operation data yet.");

      const multiplicationRows = Object.keys(state.lifetimeStats.multiplicationTables)
        .map((key) => Number(key))
        .filter((value) => Number.isInteger(value))
        .sort((a, b) => a - b)
        .map((table) => {
          const metrics = bucketToMetrics(state.lifetimeStats.multiplicationTables[String(table)]);
          return {
            label: `${table}s`,
            ...metrics
          };
        });
      renderStatsTableRows(multiplicationStatsBody, multiplicationRows, "No multiplication-table data yet.");

      const divisionRows = Object.keys(state.lifetimeStats.divisionTables)
        .map((key) => Number(key))
        .filter((value) => Number.isInteger(value))
        .sort((a, b) => a - b)
        .map((divisor) => {
          const metrics = bucketToMetrics(state.lifetimeStats.divisionTables[String(divisor)]);
          return {
            label: `${divisor}s`,
            ...metrics
          };
        });
      renderStatsTableRows(divisionStatsBody, divisionRows, "No division-table data yet.");

      const multiplicationSingleRows = Object.keys(state.lifetimeStats.multiplicationSingles)
        .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
        .map((key) => {
          const metrics = bucketToMetrics(state.lifetimeStats.multiplicationSingles[key]);
          return {
            label: key,
            ...metrics
          };
        });
      renderStatsTableRows(multiplicationSingleStatsBody, multiplicationSingleRows, "No multiplication single-pattern data yet.");

      const additionPairRows = Object.keys(state.lifetimeStats.additionPairs)
        .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
        .map((key) => {
          const metrics = bucketToMetrics(state.lifetimeStats.additionPairs[key]);
          return {
            label: key,
            ...metrics
          };
        });
      renderStatsTableRows(additionPairStatsBody, additionPairRows, "No addition pair data yet.");

      const subtractionPairRows = Object.keys(state.lifetimeStats.subtractionPairs)
        .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
        .map((key) => {
          const metrics = bucketToMetrics(state.lifetimeStats.subtractionPairs[key]);
          return {
            label: key,
            ...metrics
          };
        });
      renderStatsTableRows(subtractionPairStatsBody, subtractionPairRows, "No subtraction pair data yet.");

      renderOperationSpeedChart(operationRows);
      renderTableHeatmap(multiplicationRows);
      renderTierDistribution([...operationRows, ...multiplicationRows, ...divisionRows]);
    }

    function setView(view) {
      state.currentView = view;
      const showStats = view === "stats";
      appRoot.classList.toggle("stats-mode", showStats);
      practiceTabBtn.classList.toggle("active", !showStats);
      statsTabBtn.classList.toggle("active", showStats);
      if (showStats) {
        renderStatsPage();
      }
    }

    function recordLifetimeStats(question, elapsedMs, isCorrect) {
      if (!state.lifetimeStats || !question || !question.operation) {
        return;
      }

      const applyAttempt = (bucket) => {
        bucket.attempts += 1;
        bucket.totalTimeMs += elapsedMs;
        if (isCorrect) {
          bucket.correct += 1;
        }
      };

      const totalsBucket = state.lifetimeStats.totals;
      applyAttempt(totalsBucket);

      const operationBucket = state.lifetimeStats.operations[question.operation];
      if (operationBucket) {
        applyAttempt(operationBucket);
      }

      if (question.operation === "mul" && Number.isInteger(question.table)) {
        const key = String(question.table);
        const bucket = ensureLifetimeBucket(state.lifetimeStats.multiplicationTables, key);
        applyAttempt(bucket);

        if (Number.isInteger(question.multiplier)) {
          const digits = digitsFromNumber(question.multiplier).filter((digit) => digit >= 2);
          digits.forEach((digit) => {
            const singleKey = `${question.table}x${digit}`;
            const singleBucket = ensureLifetimeBucket(state.lifetimeStats.multiplicationSingles, singleKey);
            applyAttempt(singleBucket);
          });
        }
      }

      if (question.operation === "div" && Number.isInteger(question.table)) {
        const key = String(question.table);
        const bucket = ensureLifetimeBucket(state.lifetimeStats.divisionTables, key);
        applyAttempt(bucket);
      }

      if (question.operation === "add" && Number.isInteger(question.left) && Number.isInteger(question.right)) {
        const onesA = Math.abs(question.left) % 10;
        const onesB = Math.abs(question.right) % 10;
        const minDigit = Math.min(onesA, onesB);
        const maxDigit = Math.max(onesA, onesB);
        const pairKey = `${minDigit}+${maxDigit}`;
        const pairBucket = ensureLifetimeBucket(state.lifetimeStats.additionPairs, pairKey);
        applyAttempt(pairBucket);
      }

      if (question.operation === "sub" && Number.isInteger(question.left) && Number.isInteger(question.right)) {
        const onesA = Math.abs(question.left) % 10;
        const onesB = Math.abs(question.right) % 10;
        const pairKey = `${onesA}-${onesB}`;
        const pairBucket = ensureLifetimeBucket(state.lifetimeStats.subtractionPairs, pairKey);
        applyAttempt(pairBucket);
      }

      saveLifetimeStats();
    }

    function buildCandidateList(min, max, excludedSet) {
      const values = [];
      for (let value = min; value <= max; value += 1) {
        if (excludedSet && excludedSet.has(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }

    function getNormalTableCandidates(maxTable) {
      const candidates = buildCandidateList(1, maxTable, new Set([1, 10]));
      return candidates.length ? candidates : buildCandidateList(1, maxTable, null);
    }

    function getWideTableCandidates() {
      return buildCandidateList(2, 12, new Set([10]));
    }

    function getWideMultiplierCandidates() {
      return buildCandidateList(2, 100, new Set([10, 100]));
    }

    function getDivisionDivisorCandidates() {
      return buildCandidateList(2, 12, new Set([10]));
    }

    function getDivisionQuotientCandidates() {
      return buildCandidateList(2, 100, null);
    }

    function parseTableFromKey(key) {
      if (!key || !key.startsWith("table-")) {
        return null;
      }
      const parsed = Number(key.slice(6));
      return Number.isInteger(parsed) ? parsed : null;
    }

    function parseOperationFromKey(key) {
      if (!key || !key.startsWith("op-")) {
        return null;
      }
      const operation = key.slice(3);
      return OPERATION_LABELS[operation] ? operation : null;
    }

    function describeQuestionSet(questionSet, maxTable) {
      if (questionSet === "diagnostic-mixed") {
        return "Diagnostic mixed with balanced coverage (+, -, x, /), weighted toward multiplication";
      }
      if (questionSet === "curated-zetamac") {
        return "Curated Zetamac booster: adaptive 2-12 x 2-100 coaching cycle";
      }
      if (questionSet === "times-normal") {
        return `Times tables: 1-${maxTable} x 1-${maxTable} (without x1/x10 prompts)`;
      }
      if (questionSet === "times-wide") {
        return "Times tables: 2-12 x 2-100 (without x10/x100 prompts)";
      }
      if (questionSet === "addition") {
        return "Addition: 2-200 + 2-200";
      }
      if (questionSet === "subtraction") {
        return "Subtraction: non-negative answers";
      }
      if (questionSet === "division") {
        return "Division: integer answers (without /1 or /10)";
      }
      return "Mixed operations: +, -, x, /";
    }

    function updateSetHint() {
      const questionSet = questionSetSelect.value;
      const hints = {
        "diagnostic-mixed": "Recommended first: balanced diagnostic with guaranteed 2-12 table rotation (including 12s) plus +, -, and / coverage.",
        "curated-zetamac": "Adaptive coaching loop: trains weak tables/pairs until balanced and faster, then sends you to the next diagnostic cycle.",
        "times-normal": "Normal table mode excludes x1 and x10 prompts to keep reps non-trivial.",
        "times-wide": "Wide mode uses 2-12 x 2-100 and removes x10/x100 prompts.",
        addition: "Addition mode uses values from 2 to 200.",
        subtraction: "Subtraction mode keeps answers non-negative.",
        division: "Division mode keeps integer answers and removes /1 and /10 prompts.",
        mixed: "Mixed mode rotates +, -, x, / with non-trivial multiplication/division."
      };
      setHintEl.textContent = hints[questionSet];
      maxTableSelect.disabled = questionSet !== "times-normal";
    }

    function resetAreaStats() {
      state.areaStats = {};
    }

    function resetDiagnosticSampling() {
      state.diagnosticOpBag = [];
      state.diagnosticMulTableBag = [];
    }

    function ensureAreaStats(areaKey, areaLabel) {
      if (!state.areaStats[areaKey]) {
        state.areaStats[areaKey] = {
          key: areaKey,
          label: areaLabel,
          attempts: 0,
          correct: 0,
          totalTimeMs: 0
        };
      }
      return state.areaStats[areaKey];
    }

    function resolveFocusKey(focusKey) {
      if (!focusKey) {
        return null;
      }

      const table = parseTableFromKey(focusKey);
      const op = parseOperationFromKey(focusKey);

      if (state.questionSet === "times-normal") {
        const candidates = getNormalTableCandidates(state.maxTable);
        return table && candidates.includes(table) ? focusKey : null;
      }

      if (state.questionSet === "curated-zetamac") {
        const candidates = getWideTableCandidates();
        if (table && candidates.includes(table)) {
          return focusKey;
        }
        if (op) {
          return focusKey;
        }
        return null;
      }

      if (state.questionSet === "times-wide") {
        const candidates = getWideTableCandidates();
        return table && candidates.includes(table) ? focusKey : null;
      }

      if (state.questionSet === "mixed" || state.questionSet === "diagnostic-mixed") {
        if (op) {
          return focusKey;
        }
        const tableCandidates = getWideTableCandidates();
        return table && tableCandidates.includes(table) ? focusKey : null;
      }

      return null;
    }

    function getDefaultCuratedPlan() {
      const tableRows = getWideTableCandidates().map((table) => ({
        table,
        score: 1,
        weight: 1
      }));
      const operationRows = OPERATION_ORDER.map((operation) => ({
        operation,
        score: 1,
        weight: CURATED_BASE_OPERATION_WEIGHTS[operation]
      }));
      return {
        createdAt: Date.now(),
        source: "default",
        tableRows,
        operationRows,
        multiplicationSingleRows: [],
        additionPairRows: [],
        subtractionPairRows: [],
        divisionRows: []
      };
    }

    function getCurrentPlanSummary() {
      if (!state.curatedPlan || !state.curatedPlan.tableRows || !state.curatedPlan.tableRows.length) {
        return "balanced weak-table training";
      }
      const top = state.curatedPlan.tableRows.slice(0, 3).map((row) => `${row.table}s`).join(", ");
      const cycle = state.curatedPlan.cycle || state.coachCycle;
      const target = state.curatedPlan.targetMeanMs ? `${(state.curatedPlan.targetMeanMs / 1000).toFixed(2)}s` : "n/a";
      return `cycle ${cycle}, target ${target}, priority tables: ${top}`;
    }

    function getFocusModeLabel() {
      if (!state.focusKey) {
        if (state.questionSet === "curated-zetamac") {
          return `Curated booster (${getCurrentPlanSummary()})`;
        }
        return `Mode: ${describeQuestionSet(state.questionSet, state.maxTable)}`;
      }

      const table = parseTableFromKey(state.focusKey);
      if (table) {
        return `Focus mode: ${table}s table`;
      }

      const op = parseOperationFromKey(state.focusKey);
      if (op) {
        return `Focus mode: ${OPERATION_LABELS[op]}`;
      }

      return `Mode: ${describeQuestionSet(state.questionSet, state.maxTable)}`;
    }

    function buildAdditionQuestion(areaKey = "op-add", areaLabel = OPERATION_LABELS.add) {
      const left = randInt(2, 200);
      const right = randInt(2, 200);
      return {
        prompt: `${left} + ${right} = ?`,
        answer: left + right,
        areaKey,
        areaLabel,
        operation: "add",
        table: null,
        left,
        right
      };
    }

    function buildSubtractionQuestion(areaKey = "op-sub", areaLabel = OPERATION_LABELS.sub) {
      const right = randInt(2, 200);
      const left = randInt(right, 220);
      return {
        prompt: `${left} - ${right} = ?`,
        answer: left - right,
        areaKey,
        areaLabel,
        operation: "sub",
        table: null,
        left,
        right
      };
    }

    function buildTimesNormalQuestion(fixedTable = null) {
      const candidates = getNormalTableCandidates(state.maxTable);
      const table = fixedTable && candidates.includes(fixedTable) ? fixedTable : pickRandom(candidates);
      const multiplier = pickRandom(candidates);
      return {
        prompt: `${table} x ${multiplier} = ?`,
        answer: table * multiplier,
        areaKey: `table-${table}`,
        areaLabel: `${table}s table`,
        operation: "mul",
        table,
        multiplier
      };
    }

    function buildTimesWideQuestion(fixedTable = null, fixedMultiplier = null) {
      const tableCandidates = getWideTableCandidates();
      const multiplierCandidates = getWideMultiplierCandidates();
      const table = fixedTable && tableCandidates.includes(fixedTable) ? fixedTable : pickRandom(tableCandidates);
      const multiplier = fixedMultiplier && multiplierCandidates.includes(fixedMultiplier)
        ? fixedMultiplier
        : pickRandom(multiplierCandidates);
      return {
        prompt: `${table} x ${multiplier} = ?`,
        answer: table * multiplier,
        areaKey: `table-${table}`,
        areaLabel: `${table}s table`,
        operation: "mul",
        table,
        multiplier
      };
    }

    function buildDivisionQuestion(areaKey = "op-div", areaLabel = OPERATION_LABELS.div) {
      const divisor = pickRandom(getDivisionDivisorCandidates());
      const quotient = pickRandom(getDivisionQuotientCandidates());
      const dividend = divisor * quotient;
      return {
        prompt: `${dividend} / ${divisor} = ?`,
        answer: quotient,
        areaKey,
        areaLabel,
        operation: "div",
        table: divisor,
        dividend,
        divisor,
        quotient
      };
    }

    function buildMixedQuestion(questionSet) {
      const focusedTable = parseTableFromKey(state.focusKey);
      const focusedOperation = parseOperationFromKey(state.focusKey);

      let operation;
      if (focusedTable) {
        operation = "mul";
      } else if (focusedOperation) {
        operation = focusedOperation;
      } else if (questionSet === "diagnostic-mixed") {
        operation = drawFromBag("diagnosticOpBag", DIAGNOSTIC_OP_CYCLE, false);
      } else {
        operation = pickRandom(["add", "sub", "mul", "div"]);
      }

      if (operation === "add") {
        return buildAdditionQuestion("op-add", OPERATION_LABELS.add);
      }
      if (operation === "sub") {
        return buildSubtractionQuestion("op-sub", OPERATION_LABELS.sub);
      }
      if (operation === "div") {
        return buildDivisionQuestion("op-div", OPERATION_LABELS.div);
      }

      if (questionSet === "diagnostic-mixed") {
        const sampledTable = focusedTable || drawFromBag("diagnosticMulTableBag", getWideTableCandidates());
        return buildTimesWideQuestion(sampledTable);
      }
      return buildTimesWideQuestion(focusedTable);
    }

    function calculateWeaknessScore(entry, baselineMs = 2400) {
      return bucketWeaknessScore(entry, baselineMs);
    }

    function buildCuratedPlanFromDiagnostic(options = {}) {
      const source = options.source || "diagnostic";
      const previousPlan = options.previousPlan || state.curatedPlan;
      const candidates = getWideTableCandidates();
      const tableRows = candidates.map((table) => {
        const key = `table-${table}`;
        const entry = state.areaStats[key];
        const score = entry && entry.attempts ? calculateWeaknessScore(entry) : null;
        return {
          table,
          attempts: entry ? entry.attempts : 0,
          score,
          weight: 1
        };
      });

      const observedTableScores = tableRows.filter((row) => row.score !== null).map((row) => row.score);
      const tableFallback = average(observedTableScores, 2400);
      tableRows.forEach((row) => {
        if (row.score === null) {
          row.score = tableFallback * 1.04;
        }
      });
      tableRows.sort((a, b) => b.score - a.score);
      applyRankWeights(tableRows, 3.4, 1);

      const mulScore = average(tableRows.map((row) => row.score), tableFallback);
      const operationRows = OPERATION_ORDER.map((operation) => {
        const roundEntry = state.areaStats[`op-${operation}`];
        const roundScore = roundEntry && roundEntry.attempts
          ? calculateWeaknessScore(roundEntry, tableFallback)
          : null;
        const lifetimeBucket = state.lifetimeStats && state.lifetimeStats.operations
          ? state.lifetimeStats.operations[operation]
          : null;
        const lifetimeScore = lifetimeBucket && lifetimeBucket.attempts
          ? bucketWeaknessScore(lifetimeBucket, tableFallback)
          : null;
        const defaultScore = operation === "mul" ? mulScore : tableFallback * 0.95;
        const combinedScore = average(
          [roundScore, lifetimeScore].filter((score) => Number.isFinite(score)),
          defaultScore
        );
        return {
          operation,
          score: combinedScore,
          weight: CURATED_BASE_OPERATION_WEIGHTS[operation]
        };
      });
      const operationScoreMean = average(operationRows.map((row) => row.score), tableFallback);
      operationRows.forEach((row) => {
        const weaknessFactor = row.score / (operationScoreMean || 1);
        row.weight = CURATED_BASE_OPERATION_WEIGHTS[row.operation] * (0.65 + weaknessFactor);
      });
      operationRows.sort((a, b) => b.weight - a.weight);

      const allowedTableSet = new Set(candidates);
      const multiplicationSingleRows = topWeakRowsFromMap(
        state.lifetimeStats ? state.lifetimeStats.multiplicationSingles : {},
        (key) => key,
        { minAttempts: 1, limit: 18 }
      )
        .map((row) => {
          const parsed = parseMulSingleKey(row.key);
          if (!parsed || !allowedTableSet.has(parsed.table) || parsed.digit < 2 || parsed.digit > 9) {
            return null;
          }
          return {
            ...row,
            table: parsed.table,
            digit: parsed.digit,
            weight: 1
          };
        })
        .filter(Boolean);
      applyRankWeights(multiplicationSingleRows, 2.3, 0.6);

      const additionPairRows = topWeakRowsFromMap(
        state.lifetimeStats ? state.lifetimeStats.additionPairs : {},
        (key) => key,
        { minAttempts: 1, limit: 14 }
      )
        .map((row) => {
          const parsed = parseAddPairKey(row.key);
          if (!parsed) {
            return null;
          }
          return {
            ...row,
            a: parsed.a,
            b: parsed.b,
            weight: 1
          };
        })
        .filter(Boolean);
      applyRankWeights(additionPairRows, 2.1, 0.5);

      const subtractionPairRows = topWeakRowsFromMap(
        state.lifetimeStats ? state.lifetimeStats.subtractionPairs : {},
        (key) => key,
        { minAttempts: 1, limit: 14 }
      )
        .map((row) => {
          const parsed = parseSubPairKey(row.key);
          if (!parsed) {
            return null;
          }
          return {
            ...row,
            a: parsed.a,
            b: parsed.b,
            weight: 1
          };
        })
        .filter(Boolean);
      applyRankWeights(subtractionPairRows, 2.1, 0.5);

      const divisionRows = Object.keys(state.lifetimeStats ? state.lifetimeStats.divisionTables : {})
        .map((key) => {
          const divisor = Number(key);
          const bucket = state.lifetimeStats.divisionTables[key];
          if (!Number.isInteger(divisor) || !bucket || bucket.attempts < 1) {
            return null;
          }
          if (!getDivisionDivisorCandidates().includes(divisor)) {
            return null;
          }
          const score = bucketWeaknessScore(bucket, tableFallback);
          if (!Number.isFinite(score)) {
            return null;
          }
          return {
            divisor,
            attempts: bucket.attempts,
            score,
            weight: 1
          };
        })
        .filter(Boolean)
        .sort((a, b) => b.score - a.score);
      applyRankWeights(divisionRows, 2.2, 0.7);

      const baselineTableAvgMs = average(
        tableRows.map((row) => row.score),
        2400
      );
      const diagnosticTableMeanMs = source === "diagnostic"
        ? baselineTableAvgMs
        : (previousPlan && previousPlan.diagnosticTableMeanMs) || baselineTableAvgMs;
      const targetMeanMs = source === "diagnostic"
        ? diagnosticTableMeanMs * CURATED_SPEED_IMPROVEMENT_TARGET
        : (previousPlan && previousPlan.targetMeanMs) || diagnosticTableMeanMs * CURATED_SPEED_IMPROVEMENT_TARGET;
      const cycle = source === "diagnostic"
        ? ((previousPlan && previousPlan.cycle) || state.coachCycle || 0) + 1
        : ((previousPlan && previousPlan.cycle) || state.coachCycle || 1);

      return {
        createdAt: Date.now(),
        source,
        cycle,
        diagnosticTableMeanMs,
        targetMeanMs,
        tableRows,
        operationRows,
        multiplicationSingleRows,
        additionPairRows,
        subtractionPairRows,
        divisionRows
      };
    }

    function getLifetimeWideTableRows() {
      const candidates = getWideTableCandidates();
      return candidates.map((table) => {
        const bucket = state.lifetimeStats && state.lifetimeStats.multiplicationTables
          ? state.lifetimeStats.multiplicationTables[String(table)]
          : null;
        const attempts = bucket ? bucket.attempts : 0;
        const avgSeconds = attempts ? bucket.totalTimeMs / attempts / 1000 : null;
        return {
          table,
          attempts,
          avgSeconds
        };
      });
    }

    function evaluateCuratedProgress(plan) {
      const usableRows = getLifetimeWideTableRows().filter((row) => row.attempts >= CURATED_MIN_TABLE_ATTEMPTS && row.avgSeconds !== null);
      if (usableRows.length < 6) {
        return {
          readyForDiagnostic: false,
          balanced: false,
          speedMet: false,
          insufficientData: true,
          sampledTables: usableRows.length,
          requiredTables: 6,
          averageSeconds: null,
          targetSeconds: plan && plan.targetMeanMs ? plan.targetMeanMs / 1000 : null,
          balanceRatio: null
        };
      }

      const avgSeconds = average(usableRows.map((row) => row.avgSeconds));
      const minSeconds = Math.min(...usableRows.map((row) => row.avgSeconds));
      const maxSeconds = Math.max(...usableRows.map((row) => row.avgSeconds));
      const balanceRatio = maxSeconds / Math.max(minSeconds, 0.01);
      const targetSeconds = plan && plan.targetMeanMs ? plan.targetMeanMs / 1000 : avgSeconds;
      const balanced = balanceRatio <= CURATED_BALANCE_RATIO_TARGET;
      const speedMet = avgSeconds <= targetSeconds;

      return {
        readyForDiagnostic: balanced && speedMet,
        balanced,
        speedMet,
        insufficientData: false,
        sampledTables: usableRows.length,
        requiredTables: 6,
        averageSeconds: avgSeconds,
        targetSeconds,
        balanceRatio
      };
    }

    function pickWeightedRow(rows) {
      const totalWeight = rows.reduce((sum, row) => sum + row.weight, 0);
      let cursor = Math.random() * totalWeight;
      for (const row of rows) {
        cursor -= row.weight;
        if (cursor <= 0) {
          return row;
        }
      }
      return rows[rows.length - 1];
    }

    function buildAdditionPairQuestion(a, b) {
      const onesA = Math.max(0, Math.min(9, a));
      const onesB = Math.max(0, Math.min(9, b));
      const left = randInt(1, 19) * 10 + onesA;
      const right = randInt(1, 19) * 10 + onesB;
      return {
        prompt: `${left} + ${right} = ?`,
        answer: left + right,
        areaKey: "op-add",
        areaLabel: OPERATION_LABELS.add,
        operation: "add",
        table: null,
        left,
        right
      };
    }

    function buildSubtractionPairQuestion(a, b) {
      const onesA = Math.max(0, Math.min(9, a));
      const onesB = Math.max(0, Math.min(9, b));
      const rightTens = randInt(1, 18);
      const leftTens = Math.min(22, rightTens + (onesA < onesB ? randInt(1, 4) : randInt(0, 4)));
      let left = leftTens * 10 + onesA;
      const right = rightTens * 10 + onesB;
      if (left < right) {
        left += 10;
      }
      return {
        prompt: `${left} - ${right} = ?`,
        answer: left - right,
        areaKey: "op-sub",
        areaLabel: OPERATION_LABELS.sub,
        operation: "sub",
        table: null,
        left,
        right
      };
    }

    function buildDivisionQuestionByDivisor(divisor) {
      const validDivisors = getDivisionDivisorCandidates();
      const chosenDivisor = validDivisors.includes(divisor) ? divisor : pickRandom(validDivisors);
      const quotient = pickRandom(getDivisionQuotientCandidates());
      const dividend = chosenDivisor * quotient;
      return {
        prompt: `${dividend} / ${chosenDivisor} = ?`,
        answer: quotient,
        areaKey: "op-div",
        areaLabel: OPERATION_LABELS.div,
        operation: "div",
        table: chosenDivisor,
        dividend,
        divisor: chosenDivisor,
        quotient
      };
    }

    function buildCuratedMultiplicationQuestion(fixedTable = null) {
      const tableCandidates = getWideTableCandidates();
      let table = fixedTable && tableCandidates.includes(fixedTable) ? fixedTable : null;
      if (!table) {
        const priorityPool = state.curatedPlan.tableRows && state.curatedPlan.tableRows.length
          ? state.curatedPlan.tableRows.slice(0, 6)
          : tableCandidates.map((value) => ({ table: value, weight: 1 }));
        table = pickWeightedRow(priorityPool).table;
      }

      if (state.curatedPlan.multiplicationSingleRows && state.curatedPlan.multiplicationSingleRows.length) {
        const sameTableRows = state.curatedPlan.multiplicationSingleRows.filter((row) => row.table === table);
        const pool = sameTableRows.length ? sameTableRows : state.curatedPlan.multiplicationSingleRows;
        if (pool.length && Math.random() < 0.68) {
          const targeted = pickWeightedRow(pool);
          const matchingMultipliers = getWideMultiplierCandidates().filter((value) =>
            String(value).includes(String(targeted.digit))
          );
          if (matchingMultipliers.length) {
            const multiplier = pickRandom(matchingMultipliers);
            return buildTimesWideQuestion(table, multiplier);
          }
        }
      }

      return buildTimesWideQuestion(table);
    }

    function buildCuratedQuestion() {
      if (!state.curatedPlan) {
        state.curatedPlan = getDefaultCuratedPlan();
      }

      const focusedTable = parseTableFromKey(state.focusKey);
      if (focusedTable) {
        return buildCuratedMultiplicationQuestion(focusedTable);
      }

      let operation = parseOperationFromKey(state.focusKey);
      if (!operation) {
        const operationRows = state.curatedPlan.operationRows && state.curatedPlan.operationRows.length
          ? state.curatedPlan.operationRows
          : OPERATION_ORDER.map((op) => ({ operation: op, weight: CURATED_BASE_OPERATION_WEIGHTS[op] }));
        operation = pickWeightedRow(operationRows).operation;
      }

      if (operation === "add") {
        if (state.curatedPlan.additionPairRows && state.curatedPlan.additionPairRows.length && Math.random() < 0.7) {
          const pair = pickWeightedRow(state.curatedPlan.additionPairRows);
          return buildAdditionPairQuestion(pair.a, pair.b);
        }
        return buildAdditionQuestion("op-add", OPERATION_LABELS.add);
      }

      if (operation === "sub") {
        if (state.curatedPlan.subtractionPairRows && state.curatedPlan.subtractionPairRows.length && Math.random() < 0.7) {
          const pair = pickWeightedRow(state.curatedPlan.subtractionPairRows);
          return buildSubtractionPairQuestion(pair.a, pair.b);
        }
        return buildSubtractionQuestion("op-sub", OPERATION_LABELS.sub);
      }

      if (operation === "div") {
        if (state.curatedPlan.divisionRows && state.curatedPlan.divisionRows.length && Math.random() < 0.7) {
          const row = pickWeightedRow(state.curatedPlan.divisionRows);
          return buildDivisionQuestionByDivisor(row.divisor);
        }
        return buildDivisionQuestion("op-div", OPERATION_LABELS.div);
      }

      return buildCuratedMultiplicationQuestion(null);
    }

    function buildQuestion() {
      if (state.questionSet === "diagnostic-mixed") {
        return buildMixedQuestion("diagnostic-mixed");
      }
      if (state.questionSet === "curated-zetamac") {
        return buildCuratedQuestion();
      }
      if (state.questionSet === "times-normal") {
        return buildTimesNormalQuestion(parseTableFromKey(state.focusKey));
      }
      if (state.questionSet === "times-wide") {
        return buildTimesWideQuestion(parseTableFromKey(state.focusKey));
      }
      if (state.questionSet === "addition") {
        return buildAdditionQuestion("op-add", OPERATION_LABELS.add);
      }
      if (state.questionSet === "subtraction") {
        return buildSubtractionQuestion("op-sub", OPERATION_LABELS.sub);
      }
      if (state.questionSet === "division") {
        return buildDivisionQuestion("op-div", OPERATION_LABELS.div);
      }
      return buildMixedQuestion("mixed");
    }

    function updateHud() {
      const accuracy = state.attempted ? Math.round((state.correct / state.attempted) * 100) : 0;
      scoreEl.textContent = `Score: ${state.score}`;
      accuracyEl.textContent = `Accuracy: ${accuracy}%`;
    }

    function updateTimer() {
      if (!state.active) {
        return;
      }
      const remainingMs = Math.max(0, state.endAt - performance.now());
      timerEl.textContent = `${(remainingMs / 1000).toFixed(1)}s`;
      if (remainingMs <= 0) {
        finishRound();
      }
    }

    function nextQuestion() {
      clearPendingFeedbackTimeout();
      feedbackEl.textContent = "";
      feedbackEl.className = "feedback";
      state.currentQuestion = buildQuestion();
      problemEl.textContent = state.currentQuestion.prompt;
      state.questionStartedAt = performance.now();
      answerInput.value = "";
      answerInput.disabled = false;
      answerInput.focus();
    }

    function startRound(focusKey = null) {
      if (state.timerId) {
        clearInterval(state.timerId);
      }

      state.durationSec = Number(durationSelect.value);
      state.maxTable = Number(maxTableSelect.value);
      state.questionSet = questionSetSelect.value;
      state.focusKey = resolveFocusKey(focusKey);

      if (state.questionSet === "curated-zetamac" && !state.curatedPlan) {
        state.curatedPlan = getDefaultCuratedPlan();
      }

      state.attempted = 0;
      state.correct = 0;
      state.score = 0;
      state.active = true;
      resetAreaStats();
      resetDiagnosticSampling();
      state.endAt = performance.now() + state.durationSec * 1000;
      setView("practice");
      clearPendingFeedbackTimeout();

      modeEl.textContent = getFocusModeLabel();
      feedbackEl.textContent = "";
      feedbackEl.className = "feedback";
      updateHud();
      timerEl.textContent = `${state.durationSec.toFixed(1)}s`;

      gameSection.classList.remove("hidden");
      resultsSection.classList.add("hidden");
      answerInput.disabled = false;
      nextQuestion();

      state.timerId = setInterval(updateTimer, 100);
    }

    function finishRound() {
      if (!state.active) {
        return;
      }
      state.active = false;
      clearPendingFeedbackTimeout();
      clearInterval(state.timerId);
      state.timerId = null;
      answerInput.disabled = true;
      renderResults();
    }

    function renderResults() {
      const areas = Object.values(state.areaStats)
        .filter((entry) => entry.attempts > 0)
        .map((entry) => {
          const totalSeconds = entry.totalTimeMs / 1000;
          return {
            key: entry.key,
            label: entry.label,
            attempts: entry.attempts,
            totalSeconds,
            avgSeconds: totalSeconds / entry.attempts,
            accuracyPct: (entry.correct / entry.attempts) * 100
          };
        });

      areas.sort((a, b) => b.avgSeconds - a.avgSeconds);
      const maxAvg = areas.length ? areas[0].avgSeconds : 0;

      summaryEl.innerHTML = "";
      const summaryCards = [
        `Mode: ${describeQuestionSet(state.questionSet, state.maxTable)}`,
        `Problems attempted: ${state.attempted}`,
        `Correct: ${state.correct}`,
        `Final score: ${state.score}`,
        `Overall accuracy: ${state.attempted ? Math.round((state.correct / state.attempted) * 100) : 0}%`
      ];
      summaryCards.forEach((text) => {
        const card = document.createElement("div");
        card.className = "card";
        card.textContent = text;
        summaryEl.appendChild(card);
      });

      tableStatsBody.innerHTML = "";
      practiceWeakestBtn.classList.add("hidden");
      practiceWeakestBtn.dataset.action = "";
      practiceWeakestBtn.dataset.key = "";

      if (!areas.length) {
        weaknessEl.textContent = "No completed problems this round. Start another round to generate weakness analysis.";
        resultsSection.classList.remove("hidden");
        return;
      }

      if (state.questionSet === "diagnostic-mixed") {
        state.curatedPlan = buildCuratedPlanFromDiagnostic({
          source: "diagnostic",
          previousPlan: state.curatedPlan
        });
        state.coachCycle = state.curatedPlan.cycle || state.coachCycle;
        const topTables = state.curatedPlan.tableRows.slice(0, 4).map((row) => `${row.table}s`).join(", ");
        const topSingles = (state.curatedPlan.multiplicationSingleRows || []).slice(0, 3).map((row) => row.label).join(", ");
        const topAddPairs = (state.curatedPlan.additionPairRows || []).slice(0, 2).map((row) => row.label).join(", ");
        const topSubPairs = (state.curatedPlan.subtractionPairRows || []).slice(0, 2).map((row) => row.label).join(", ");
        const target = state.curatedPlan.targetMeanMs ? `${(state.curatedPlan.targetMeanMs / 1000).toFixed(2)}s` : "n/a";
        let message = `Diagnostic cycle ${state.coachCycle} complete. Priority multiplication tables: ${topTables}. Target average speed for this cycle: ${target}.`;
        if (topSingles) {
          message += ` Weak single-facts: ${topSingles}.`;
        }
        if (topAddPairs) {
          message += ` Addition pairs to drill: ${topAddPairs}.`;
        }
        if (topSubPairs) {
          message += ` Subtraction pairs to drill: ${topSubPairs}.`;
        }
        message += " Curated mode now adapts by both average time and mistakes.";
        weaknessEl.textContent = message;
        practiceWeakestBtn.dataset.action = "curated";
        practiceWeakestBtn.textContent = "Start Curated Zetamac Booster";
        practiceWeakestBtn.classList.remove("hidden");
      } else if (state.questionSet === "curated-zetamac") {
        state.curatedPlan = buildCuratedPlanFromDiagnostic({
          source: "curated-refresh",
          previousPlan: state.curatedPlan
        });
        const progress = evaluateCuratedProgress(state.curatedPlan);
        if (progress.readyForDiagnostic) {
          weaknessEl.textContent = `Cycle ${state.coachCycle} goal reached. Tables are balanced (spread ratio ${progress.balanceRatio.toFixed(2)}) and average speed ${progress.averageSeconds.toFixed(2)}s met target ${progress.targetSeconds.toFixed(2)}s. Run the next diagnostic cycle to push speed further.`;
          practiceWeakestBtn.dataset.action = "diagnostic";
          practiceWeakestBtn.textContent = "Run Next Diagnostic Cycle";
          practiceWeakestBtn.classList.remove("hidden");
        } else if (progress.insufficientData) {
          weaknessEl.textContent = `Curated coaching in progress. Need more table coverage before evaluating balance (${progress.sampledTables}/${progress.requiredTables} tables have at least ${CURATED_MIN_TABLE_ATTEMPTS} attempts).`;
          practiceWeakestBtn.dataset.action = "curated";
          practiceWeakestBtn.textContent = "Continue Curated Booster";
          practiceWeakestBtn.classList.remove("hidden");
        } else {
          const balanceText = progress.balanced ? "balanced" : "still uneven";
          const speedText = progress.speedMet ? "speed target met" : "speed target not met yet";
          weaknessEl.textContent = `Curated coaching in progress: table spread ratio ${progress.balanceRatio.toFixed(2)} (${balanceText}), average speed ${progress.averageSeconds.toFixed(2)}s vs target ${progress.targetSeconds.toFixed(2)}s (${speedText}). Continue curated practice until both pass.`;
          practiceWeakestBtn.dataset.action = "curated";
          practiceWeakestBtn.textContent = "Continue Curated Booster";
          practiceWeakestBtn.classList.remove("hidden");
        }
      } else {
        const weakest = areas[0];
        if (weakest.key.startsWith("table-")) {
          weaknessEl.textContent = `Your slowest average was on the ${weakest.label}: ${weakest.avgSeconds.toFixed(2)}s per prompt across ${weakest.attempts} prompts.`;
        } else {
          weaknessEl.textContent = `Your slowest average area was ${weakest.label}: ${weakest.avgSeconds.toFixed(2)}s per prompt across ${weakest.attempts} prompts.`;
        }

        if (areas.length > 1) {
          practiceWeakestBtn.dataset.action = "focus";
          practiceWeakestBtn.dataset.key = weakest.key;
          practiceWeakestBtn.textContent = weakest.key.startsWith("table-")
            ? `Practice ${weakest.label}`
            : `Focus on ${weakest.label}`;
          practiceWeakestBtn.classList.remove("hidden");
        }
      }

      areas.forEach((row, index) => {
        const tr = document.createElement("tr");
        if (index === 0) {
          tr.classList.add("top");
        }
        const barPct = maxAvg ? Math.max(6, Math.round((row.avgSeconds / maxAvg) * 100)) : 6;
        tr.innerHTML = `
          <td>${row.label}</td>
          <td>${row.attempts}</td>
          <td>
            <div class="bar-wrap">
              <div class="bar" style="width:${barPct}%"></div>
              <span>${row.totalSeconds.toFixed(2)}s</span>
            </div>
          </td>
          <td>${row.avgSeconds.toFixed(2)}s</td>
          <td>${Math.round(row.accuracyPct)}%</td>
        `;
        tableStatsBody.appendChild(tr);
      });

      resultsSection.classList.remove("hidden");
    }

    answerForm.addEventListener("submit", (event) => {
      event.preventDefault();
      if (!state.active || !state.currentQuestion) {
        return;
      }

      const raw = answerInput.value.trim();
      if (raw === "") {
        return;
      }

      const userValue = Number(raw);
      if (!Number.isFinite(userValue)) {
        feedbackEl.textContent = "Enter a number.";
        feedbackEl.className = "feedback bad";
        answerInput.select();
        return;
      }

      const now = performance.now();
      const elapsed = now - state.questionStartedAt;
      const current = state.currentQuestion;
      const stats = ensureAreaStats(current.areaKey, current.areaLabel);

      state.attempted += 1;
      stats.attempts += 1;
      stats.totalTimeMs += elapsed;

      const isCorrect = userValue === current.answer;
      if (isCorrect) {
        state.correct += 1;
        state.score += 1;
        stats.correct += 1;
        feedbackEl.textContent = "Correct";
        feedbackEl.className = "feedback ok";
      } else {
        feedbackEl.textContent = `Correct answer: ${current.answer}`;
        feedbackEl.className = "feedback bad";
      }

      recordLifetimeStats(current, elapsed, isCorrect);
      updateHud();

      if (now >= state.endAt) {
        finishRound();
        return;
      }

      if (!isCorrect) {
        answerInput.disabled = true;
        clearPendingFeedbackTimeout();
        state.feedbackTimeoutId = setTimeout(() => {
          state.feedbackTimeoutId = null;
          if (!state.active) {
            return;
          }
          if (performance.now() >= state.endAt) {
            finishRound();
            return;
          }
          nextQuestion();
        }, 420);
        return;
      }

      nextQuestion();
    });

    startBtn.addEventListener("click", () => startRound(null));
    newBalancedBtn.addEventListener("click", () => startRound(null));
    practiceTabBtn.addEventListener("click", () => {
      setView("practice");
    });
    statsTabBtn.addEventListener("click", () => {
      if (state.active) {
        finishRound();
      }
      setView("stats");
    });
    practiceWeakestBtn.addEventListener("click", () => {
      const action = practiceWeakestBtn.dataset.action;
      if (action === "curated") {
        questionSetSelect.value = "curated-zetamac";
        updateSetHint();
        startRound(null);
        return;
      }
      if (action === "diagnostic") {
        questionSetSelect.value = "diagnostic-mixed";
        updateSetHint();
        startRound(null);
        return;
      }
      if (action === "focus") {
        const focusKey = practiceWeakestBtn.dataset.key;
        if (focusKey) {
          startRound(focusKey);
        }
      }
    });
    resetStatsBtn.addEventListener("click", () => {
      const shouldReset = window.confirm("Reset all lifetime stats on this browser?");
      if (!shouldReset) {
        return;
      }
      state.lifetimeStats = createLifetimeStats();
      state.coachCycle = 0;
      state.curatedPlan = null;
      saveLifetimeStats();
      renderStatsPage();
    });
    questionSetSelect.addEventListener("change", updateSetHint);

    loadLifetimeStats();
    renderStatsPage();
    updateSetHint();
    setView("practice");
  </script>
</body>
</html>
